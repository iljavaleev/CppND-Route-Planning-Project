/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
#define GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
#define GEN_PASS_DECL_ADDDEBUGFOUNDATION
#define GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#define GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#define GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#define GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#define GEN_PASS_DECL_ARRAYVALUECOPY
#define GEN_PASS_DECL_CFGCONVERSION
#define GEN_PASS_DECL_CHARACTERCONVERSION
#define GEN_PASS_DECL_EXTERNALNAMECONVERSION
#define GEN_PASS_DECL_MEMREFDATAFLOWOPT
#define GEN_PASS_DECL_MEMORYALLOCATIONOPT
#define GEN_PASS_DECL_SIMPLIFYINTRINSICS
#define GEN_PASS_DECL_SIMPLIFYREGIONLITE
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AbstractResultOnFuncOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
struct AbstractResultOnFuncOptOptions {
  bool passResultAsBox = false;
};
#undef GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
#endif // GEN_PASS_DECL_ABSTRACTRESULTONFUNCOPT
#ifdef GEN_PASS_DEF_ABSTRACTRESULTONFUNCOPT
namespace impl {

template <typename DerivedT>
class AbstractResultOnFuncOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = AbstractResultOnFuncOptBase;

  AbstractResultOnFuncOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnFuncOptBase(const AbstractResultOnFuncOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-func-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-func-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnFuncOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnFuncOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnFuncOptBase<DerivedT>)

  AbstractResultOnFuncOptBase(const AbstractResultOnFuncOptOptions &options) : AbstractResultOnFuncOptBase() {
    passResultAsBox = options.passResultAsBox;
  }
protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ABSTRACTRESULTONFUNCOPT
#endif // GEN_PASS_DEF_ABSTRACTRESULTONFUNCOPT

//===----------------------------------------------------------------------===//
// AbstractResultOnGlobalOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
struct AbstractResultOnGlobalOptOptions {
  bool passResultAsBox = false;
};
#undef GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
#endif // GEN_PASS_DECL_ABSTRACTRESULTONGLOBALOPT
#ifdef GEN_PASS_DEF_ABSTRACTRESULTONGLOBALOPT
namespace impl {

template <typename DerivedT>
class AbstractResultOnGlobalOptBase : public ::mlir::OperationPass<fir::GlobalOp> {
public:
  using Base = AbstractResultOnGlobalOptBase;

  AbstractResultOnGlobalOptBase() : ::mlir::OperationPass<fir::GlobalOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnGlobalOptBase(const AbstractResultOnGlobalOptBase &other) : ::mlir::OperationPass<fir::GlobalOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-global-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-global-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnGlobalOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnGlobalOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnGlobalOptBase<DerivedT>)

  AbstractResultOnGlobalOptBase(const AbstractResultOnGlobalOptOptions &options) : AbstractResultOnGlobalOptBase() {
    passResultAsBox = options.passResultAsBox;
  }
protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ABSTRACTRESULTONGLOBALOPT
#endif // GEN_PASS_DEF_ABSTRACTRESULTONGLOBALOPT

//===----------------------------------------------------------------------===//
// AddDebugFoundation
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDDEBUGFOUNDATION
#undef GEN_PASS_DECL_ADDDEBUGFOUNDATION
#endif // GEN_PASS_DECL_ADDDEBUGFOUNDATION
#ifdef GEN_PASS_DEF_ADDDEBUGFOUNDATION
namespace impl {

template <typename DerivedT>
class AddDebugFoundationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugFoundationBase;

  AddDebugFoundationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugFoundationBase(const AddDebugFoundationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-foundation");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-foundation"; }

  ::llvm::StringRef getDescription() const override { return "Add the foundation for debug info"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugFoundation");
  }
  ::llvm::StringRef getName() const override { return "AddDebugFoundation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugFoundationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDDEBUGFOUNDATION
#endif // GEN_PASS_DEF_ADDDEBUGFOUNDATION

//===----------------------------------------------------------------------===//
// AffineDialectDemotion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#undef GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#endif // GEN_PASS_DECL_AFFINEDIALECTDEMOTION
#ifdef GEN_PASS_DEF_AFFINEDIALECTDEMOTION
namespace impl {

template <typename DerivedT>
class AffineDialectDemotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectDemotionBase;

  AffineDialectDemotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectDemotionBase(const AffineDialectDemotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("demote-affine");
  }
  ::llvm::StringRef getArgument() const override { return "demote-affine"; }

  ::llvm::StringRef getDescription() const override { return "Converts `affine.{load,store}` back to fir operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectDemotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectDemotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectDemotionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_AFFINEDIALECTDEMOTION
#endif // GEN_PASS_DEF_AFFINEDIALECTDEMOTION

//===----------------------------------------------------------------------===//
// AffineDialectPromotion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#undef GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#endif // GEN_PASS_DECL_AFFINEDIALECTPROMOTION
#ifdef GEN_PASS_DEF_AFFINEDIALECTPROMOTION
namespace impl {

template <typename DerivedT>
class AffineDialectPromotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectPromotionBase;

  AffineDialectPromotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectPromotionBase(const AffineDialectPromotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("promote-to-affine");
  }
  ::llvm::StringRef getArgument() const override { return "promote-to-affine"; }

  ::llvm::StringRef getDescription() const override { return "Promotes `fir.{do_loop,if}` to `affine.{for,if}`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectPromotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectPromotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectPromotionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_AFFINEDIALECTPROMOTION
#endif // GEN_PASS_DEF_AFFINEDIALECTPROMOTION

//===----------------------------------------------------------------------===//
// AlgebraicSimplification
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#undef GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#endif // GEN_PASS_DECL_ALGEBRAICSIMPLIFICATION
#ifdef GEN_PASS_DEF_ALGEBRAICSIMPLIFICATION
namespace impl {

template <typename DerivedT>
class AlgebraicSimplificationBase : public ::mlir::OperationPass<> {
public:
  using Base = AlgebraicSimplificationBase;

  AlgebraicSimplificationBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AlgebraicSimplificationBase(const AlgebraicSimplificationBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("flang-algebraic-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "flang-algebraic-simplification"; }

  ::llvm::StringRef getDescription() const override { return ""; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AlgebraicSimplification");
  }
  ::llvm::StringRef getName() const override { return "AlgebraicSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::math::MathDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AlgebraicSimplificationBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ALGEBRAICSIMPLIFICATION
#endif // GEN_PASS_DEF_ALGEBRAICSIMPLIFICATION

//===----------------------------------------------------------------------===//
// AnnotateConstantOperands
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#undef GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#endif // GEN_PASS_DECL_ANNOTATECONSTANTOPERANDS
#ifdef GEN_PASS_DEF_ANNOTATECONSTANTOPERANDS
namespace impl {

template <typename DerivedT>
class AnnotateConstantOperandsBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateConstantOperandsBase;

  AnnotateConstantOperandsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateConstantOperandsBase(const AnnotateConstantOperandsBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-constant");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-constant"; }

  ::llvm::StringRef getDescription() const override { return "Annotate constant operands to all FIR operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateConstantOperands");
  }
  ::llvm::StringRef getName() const override { return "AnnotateConstantOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateConstantOperandsBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ANNOTATECONSTANTOPERANDS
#endif // GEN_PASS_DEF_ANNOTATECONSTANTOPERANDS

//===----------------------------------------------------------------------===//
// ArrayValueCopy
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ARRAYVALUECOPY
struct ArrayValueCopyOptions {
  bool optimizeConflicts = false;
};
#undef GEN_PASS_DECL_ARRAYVALUECOPY
#endif // GEN_PASS_DECL_ARRAYVALUECOPY
#ifdef GEN_PASS_DEF_ARRAYVALUECOPY
namespace impl {

template <typename DerivedT>
class ArrayValueCopyBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = ArrayValueCopyBase;

  ArrayValueCopyBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ArrayValueCopyBase(const ArrayValueCopyBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("array-value-copy");
  }
  ::llvm::StringRef getArgument() const override { return "array-value-copy"; }

  ::llvm::StringRef getDescription() const override { return "Convert array value operations to memory operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArrayValueCopy");
  }
  ::llvm::StringRef getName() const override { return "ArrayValueCopy"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArrayValueCopyBase<DerivedT>)

  ArrayValueCopyBase(const ArrayValueCopyOptions &options) : ArrayValueCopyBase() {
    optimizeConflicts = options.optimizeConflicts;
  }
protected:
  ::mlir::Pass::Option<bool> optimizeConflicts{*this, "optimize-conflicts", ::llvm::cl::desc("do more detailed conflict analysis to reduce the number of temporaries"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ARRAYVALUECOPY
#endif // GEN_PASS_DEF_ARRAYVALUECOPY

//===----------------------------------------------------------------------===//
// CFGConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CFGCONVERSION
struct CFGConversionOptions {
  bool forceLoopToExecuteOnce = false;
};
#undef GEN_PASS_DECL_CFGCONVERSION
#endif // GEN_PASS_DECL_CFGCONVERSION
#ifdef GEN_PASS_DEF_CFGCONVERSION
namespace impl {

template <typename DerivedT>
class CFGConversionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = CFGConversionBase;

  CFGConversionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CFGConversionBase(const CFGConversionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cfg-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "cfg-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert FIR structured control flow ops to CFG ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CFGConversion");
  }
  ::llvm::StringRef getName() const override { return "CFGConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CFGConversionBase<DerivedT>)

  CFGConversionBase(const CFGConversionOptions &options) : CFGConversionBase() {
    forceLoopToExecuteOnce = options.forceLoopToExecuteOnce;
  }
protected:
  ::mlir::Pass::Option<bool> forceLoopToExecuteOnce{*this, "always-execute-loop-body", ::llvm::cl::desc("force the body of a loop to execute at least once"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CFGCONVERSION
#endif // GEN_PASS_DEF_CFGCONVERSION

//===----------------------------------------------------------------------===//
// CharacterConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CHARACTERCONVERSION
struct CharacterConversionOptions {
  std::string useRuntimeCalls = std::string{};
};
#undef GEN_PASS_DECL_CHARACTERCONVERSION
#endif // GEN_PASS_DECL_CHARACTERCONVERSION
#ifdef GEN_PASS_DEF_CHARACTERCONVERSION
namespace impl {

template <typename DerivedT>
class CharacterConversionBase : public ::mlir::OperationPass<> {
public:
  using Base = CharacterConversionBase;

  CharacterConversionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CharacterConversionBase(const CharacterConversionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("character-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "character-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert CHARACTER entities with different KINDs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CharacterConversion");
  }
  ::llvm::StringRef getName() const override { return "CharacterConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CharacterConversionBase<DerivedT>)

  CharacterConversionBase(const CharacterConversionOptions &options) : CharacterConversionBase() {
    useRuntimeCalls = options.useRuntimeCalls;
  }
protected:
  ::mlir::Pass::Option<std::string> useRuntimeCalls{*this, "use-runtime-calls", ::llvm::cl::desc("Generate runtime calls to a named set of conversion routines. By default, the conversions may produce unexpected results."), ::llvm::cl::init(std::string{})};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CHARACTERCONVERSION
#endif // GEN_PASS_DEF_CHARACTERCONVERSION

//===----------------------------------------------------------------------===//
// ExternalNameConversion
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXTERNALNAMECONVERSION
#undef GEN_PASS_DECL_EXTERNALNAMECONVERSION
#endif // GEN_PASS_DECL_EXTERNALNAMECONVERSION
#ifdef GEN_PASS_DEF_EXTERNALNAMECONVERSION
namespace impl {

template <typename DerivedT>
class ExternalNameConversionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExternalNameConversionBase;

  ExternalNameConversionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExternalNameConversionBase(const ExternalNameConversionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("external-name-interop");
  }
  ::llvm::StringRef getArgument() const override { return "external-name-interop"; }

  ::llvm::StringRef getDescription() const override { return "Convert name for external interoperability"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExternalNameConversion");
  }
  ::llvm::StringRef getName() const override { return "ExternalNameConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExternalNameConversionBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXTERNALNAMECONVERSION
#endif // GEN_PASS_DEF_EXTERNALNAMECONVERSION

//===----------------------------------------------------------------------===//
// MemRefDataFlowOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMREFDATAFLOWOPT
#undef GEN_PASS_DECL_MEMREFDATAFLOWOPT
#endif // GEN_PASS_DECL_MEMREFDATAFLOWOPT
#ifdef GEN_PASS_DEF_MEMREFDATAFLOWOPT
namespace impl {

template <typename DerivedT>
class MemRefDataFlowOptBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = MemRefDataFlowOptBase;

  MemRefDataFlowOptBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemRefDataFlowOptBase(const MemRefDataFlowOptBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fir-memref-dataflow-opt");
  }
  ::llvm::StringRef getArgument() const override { return "fir-memref-dataflow-opt"; }

  ::llvm::StringRef getDescription() const override { return "Perform store/load forwarding and potentially removing dead stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemRefDataFlowOpt");
  }
  ::llvm::StringRef getName() const override { return "MemRefDataFlowOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemRefDataFlowOptBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MEMREFDATAFLOWOPT
#endif // GEN_PASS_DEF_MEMREFDATAFLOWOPT

//===----------------------------------------------------------------------===//
// MemoryAllocationOpt
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMORYALLOCATIONOPT
struct MemoryAllocationOptOptions {
  bool dynamicArrayOnHeap = false;
  std::size_t maxStackArraySize = ~static_cast<std::size_t>(0);
};
#undef GEN_PASS_DECL_MEMORYALLOCATIONOPT
#endif // GEN_PASS_DECL_MEMORYALLOCATIONOPT
#ifdef GEN_PASS_DEF_MEMORYALLOCATIONOPT
namespace impl {

template <typename DerivedT>
class MemoryAllocationOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MemoryAllocationOptBase;

  MemoryAllocationOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemoryAllocationOptBase(const MemoryAllocationOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memory-allocation-opt");
  }
  ::llvm::StringRef getArgument() const override { return "memory-allocation-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert stack to heap allocations and vice versa."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemoryAllocationOpt");
  }
  ::llvm::StringRef getName() const override { return "MemoryAllocationOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemoryAllocationOptBase<DerivedT>)

  MemoryAllocationOptBase(const MemoryAllocationOptOptions &options) : MemoryAllocationOptBase() {
    dynamicArrayOnHeap = options.dynamicArrayOnHeap;
    maxStackArraySize = options.maxStackArraySize;
  }
protected:
  ::mlir::Pass::Option<bool> dynamicArrayOnHeap{*this, "dynamic-array-on-heap", ::llvm::cl::desc("Allocate all arrays with runtime determined size on heap."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::size_t> maxStackArraySize{*this, "maximum-array-alloc-size", ::llvm::cl::desc("Set maximum number of elements of an array allocated on the stack."), ::llvm::cl::init(~static_cast<std::size_t>(0))};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MEMORYALLOCATIONOPT
#endif // GEN_PASS_DEF_MEMORYALLOCATIONOPT

//===----------------------------------------------------------------------===//
// SimplifyIntrinsics
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYINTRINSICS
struct SimplifyIntrinsicsOptions {
  bool enableExperimental = false;
};
#undef GEN_PASS_DECL_SIMPLIFYINTRINSICS
#endif // GEN_PASS_DECL_SIMPLIFYINTRINSICS
#ifdef GEN_PASS_DEF_SIMPLIFYINTRINSICS
namespace impl {

template <typename DerivedT>
class SimplifyIntrinsicsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyIntrinsicsBase;

  SimplifyIntrinsicsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyIntrinsicsBase(const SimplifyIntrinsicsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Intrinsics simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "SimplifyIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyIntrinsicsBase<DerivedT>)

  SimplifyIntrinsicsBase(const SimplifyIntrinsicsOptions &options) : SimplifyIntrinsicsBase() {
    enableExperimental = options.enableExperimental;
  }
protected:
  ::mlir::Pass::Option<bool> enableExperimental{*this, "enable-experimental", ::llvm::cl::desc("Enable experimental code that may not always work correctly"), ::llvm::cl::init(false)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYINTRINSICS
#endif // GEN_PASS_DEF_SIMPLIFYINTRINSICS

//===----------------------------------------------------------------------===//
// SimplifyRegionLite
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYREGIONLITE
#undef GEN_PASS_DECL_SIMPLIFYREGIONLITE
#endif // GEN_PASS_DECL_SIMPLIFYREGIONLITE
#ifdef GEN_PASS_DEF_SIMPLIFYREGIONLITE
namespace impl {

template <typename DerivedT>
class SimplifyRegionLiteBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyRegionLiteBase;

  SimplifyRegionLiteBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyRegionLiteBase(const SimplifyRegionLiteBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-region-lite");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-region-lite"; }

  ::llvm::StringRef getDescription() const override { return "Region simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyRegionLite");
  }
  ::llvm::StringRef getName() const override { return "SimplifyRegionLite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyRegionLiteBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYREGIONLITE
#endif // GEN_PASS_DEF_SIMPLIFYREGIONLITE
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AbstractResultOnFuncOpt Registration
//===----------------------------------------------------------------------===//

inline void registerAbstractResultOnFuncOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnFuncOptPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAbstractResultOnFuncOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnFuncOptPass();
  });
}

//===----------------------------------------------------------------------===//
// AbstractResultOnGlobalOpt Registration
//===----------------------------------------------------------------------===//

inline void registerAbstractResultOnGlobalOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnGlobalOptPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAbstractResultOnGlobalOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAbstractResultOnGlobalOptPass();
  });
}

//===----------------------------------------------------------------------===//
// AddDebugFoundation Registration
//===----------------------------------------------------------------------===//

inline void registerAddDebugFoundation() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAddDebugFoundationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddDebugFoundationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAddDebugFoundationPass();
  });
}

//===----------------------------------------------------------------------===//
// AffineDialectDemotion Registration
//===----------------------------------------------------------------------===//

inline void registerAffineDialectDemotion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAffineDemotionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAffineDialectDemotionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAffineDemotionPass();
  });
}

//===----------------------------------------------------------------------===//
// AffineDialectPromotion Registration
//===----------------------------------------------------------------------===//

inline void registerAffineDialectPromotion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createPromoteToAffinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAffineDialectPromotionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createPromoteToAffinePass();
  });
}

//===----------------------------------------------------------------------===//
// AlgebraicSimplification Registration
//===----------------------------------------------------------------------===//

inline void registerAlgebraicSimplification() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAlgebraicSimplificationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAlgebraicSimplificationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAlgebraicSimplificationPass();
  });
}

//===----------------------------------------------------------------------===//
// AnnotateConstantOperands Registration
//===----------------------------------------------------------------------===//

inline void registerAnnotateConstantOperands() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAnnotateConstantOperandsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAnnotateConstantOperandsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createAnnotateConstantOperandsPass();
  });
}

//===----------------------------------------------------------------------===//
// ArrayValueCopy Registration
//===----------------------------------------------------------------------===//

inline void registerArrayValueCopy() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createArrayValueCopyPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerArrayValueCopyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createArrayValueCopyPass();
  });
}

//===----------------------------------------------------------------------===//
// CFGConversion Registration
//===----------------------------------------------------------------------===//

inline void registerCFGConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createFirToCfgPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCFGConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createFirToCfgPass();
  });
}

//===----------------------------------------------------------------------===//
// CharacterConversion Registration
//===----------------------------------------------------------------------===//

inline void registerCharacterConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createCharacterConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCharacterConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createCharacterConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// ExternalNameConversion Registration
//===----------------------------------------------------------------------===//

inline void registerExternalNameConversion() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createExternalNameConversionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExternalNameConversionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createExternalNameConversionPass();
  });
}

//===----------------------------------------------------------------------===//
// MemRefDataFlowOpt Registration
//===----------------------------------------------------------------------===//

inline void registerMemRefDataFlowOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemDataFlowOptPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemRefDataFlowOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemDataFlowOptPass();
  });
}

//===----------------------------------------------------------------------===//
// MemoryAllocationOpt Registration
//===----------------------------------------------------------------------===//

inline void registerMemoryAllocationOpt() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemoryAllocationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemoryAllocationOptPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createMemoryAllocationPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyIntrinsics Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyIntrinsics() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyIntrinsicsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyIntrinsicsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyIntrinsicsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyRegionLite Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyRegionLite() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyRegionLitePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyRegionLitePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::fir::createSimplifyRegionLitePass();
  });
}

//===----------------------------------------------------------------------===//
// OptTransform Registration
//===----------------------------------------------------------------------===//

inline void registerOptTransformPasses() {
  registerAbstractResultOnFuncOpt();
  registerAbstractResultOnGlobalOpt();
  registerAddDebugFoundation();
  registerAffineDialectDemotion();
  registerAffineDialectPromotion();
  registerAlgebraicSimplification();
  registerAnnotateConstantOperands();
  registerArrayValueCopy();
  registerCFGConversion();
  registerCharacterConversion();
  registerExternalNameConversion();
  registerMemRefDataFlowOpt();
  registerMemoryAllocationOpt();
  registerSimplifyIntrinsics();
  registerSimplifyRegionLite();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AbstractResultOnFuncOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = AbstractResultOnFuncOptBase;

  AbstractResultOnFuncOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnFuncOptBase(const AbstractResultOnFuncOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-func-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-func-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnFuncOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnFuncOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnFuncOptBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class AbstractResultOnGlobalOptBase : public ::mlir::OperationPass<fir::GlobalOp> {
public:
  using Base = AbstractResultOnGlobalOptBase;

  AbstractResultOnGlobalOptBase() : ::mlir::OperationPass<fir::GlobalOp>(::mlir::TypeID::get<DerivedT>()) {}
  AbstractResultOnGlobalOptBase(const AbstractResultOnGlobalOptBase &other) : ::mlir::OperationPass<fir::GlobalOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("abstract-result-on-global-opt");
  }
  ::llvm::StringRef getArgument() const override { return "abstract-result-on-global-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert fir.array, fir.box and fir.rec function result to function argument"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AbstractResultOnGlobalOpt");
  }
  ::llvm::StringRef getName() const override { return "AbstractResultOnGlobalOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AbstractResultOnGlobalOptBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> passResultAsBox{*this, "abstract-result-as-box", ::llvm::cl::desc("Pass fir.array<T> result as fir.box<fir.array<T>> argument instead of fir.ref<fir.array<T>>."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class AddDebugFoundationBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugFoundationBase;

  AddDebugFoundationBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugFoundationBase(const AddDebugFoundationBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-foundation");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-foundation"; }

  ::llvm::StringRef getDescription() const override { return "Add the foundation for debug info"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugFoundation");
  }
  ::llvm::StringRef getName() const override { return "AddDebugFoundation"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugFoundationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AffineDialectDemotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectDemotionBase;

  AffineDialectDemotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectDemotionBase(const AffineDialectDemotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("demote-affine");
  }
  ::llvm::StringRef getArgument() const override { return "demote-affine"; }

  ::llvm::StringRef getDescription() const override { return "Converts `affine.{load,store}` back to fir operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectDemotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectDemotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectDemotionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AffineDialectPromotionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = AffineDialectPromotionBase;

  AffineDialectPromotionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  AffineDialectPromotionBase(const AffineDialectPromotionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("promote-to-affine");
  }
  ::llvm::StringRef getArgument() const override { return "promote-to-affine"; }

  ::llvm::StringRef getDescription() const override { return "Promotes `fir.{do_loop,if}` to `affine.{for,if}`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AffineDialectPromotion");
  }
  ::llvm::StringRef getName() const override { return "AffineDialectPromotion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  registry.insert<mlir::AffineDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AffineDialectPromotionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AlgebraicSimplificationBase : public ::mlir::OperationPass<> {
public:
  using Base = AlgebraicSimplificationBase;

  AlgebraicSimplificationBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AlgebraicSimplificationBase(const AlgebraicSimplificationBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("flang-algebraic-simplification");
  }
  ::llvm::StringRef getArgument() const override { return "flang-algebraic-simplification"; }

  ::llvm::StringRef getDescription() const override { return ""; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AlgebraicSimplification");
  }
  ::llvm::StringRef getName() const override { return "AlgebraicSimplification"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<mlir::math::MathDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AlgebraicSimplificationBase<DerivedT>)

protected:
};

template <typename DerivedT>
class AnnotateConstantOperandsBase : public ::mlir::OperationPass<> {
public:
  using Base = AnnotateConstantOperandsBase;

  AnnotateConstantOperandsBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  AnnotateConstantOperandsBase(const AnnotateConstantOperandsBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("annotate-constant");
  }
  ::llvm::StringRef getArgument() const override { return "annotate-constant"; }

  ::llvm::StringRef getDescription() const override { return "Annotate constant operands to all FIR operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AnnotateConstantOperands");
  }
  ::llvm::StringRef getName() const override { return "AnnotateConstantOperands"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AnnotateConstantOperandsBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ArrayValueCopyBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = ArrayValueCopyBase;

  ArrayValueCopyBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ArrayValueCopyBase(const ArrayValueCopyBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("array-value-copy");
  }
  ::llvm::StringRef getArgument() const override { return "array-value-copy"; }

  ::llvm::StringRef getDescription() const override { return "Convert array value operations to memory operations."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ArrayValueCopy");
  }
  ::llvm::StringRef getName() const override { return "ArrayValueCopy"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ArrayValueCopyBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> optimizeConflicts{*this, "optimize-conflicts", ::llvm::cl::desc("do more detailed conflict analysis to reduce the number of temporaries"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class CFGConversionBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = CFGConversionBase;

  CFGConversionBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CFGConversionBase(const CFGConversionBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("cfg-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "cfg-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert FIR structured control flow ops to CFG ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CFGConversion");
  }
  ::llvm::StringRef getName() const override { return "CFGConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CFGConversionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> forceLoopToExecuteOnce{*this, "always-execute-loop-body", ::llvm::cl::desc("force the body of a loop to execute at least once"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class CharacterConversionBase : public ::mlir::OperationPass<> {
public:
  using Base = CharacterConversionBase;

  CharacterConversionBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  CharacterConversionBase(const CharacterConversionBase &other) : ::mlir::OperationPass<>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("character-conversion");
  }
  ::llvm::StringRef getArgument() const override { return "character-conversion"; }

  ::llvm::StringRef getDescription() const override { return "Convert CHARACTER entities with different KINDs"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CharacterConversion");
  }
  ::llvm::StringRef getName() const override { return "CharacterConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CharacterConversionBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> useRuntimeCalls{*this, "use-runtime-calls", ::llvm::cl::desc("Generate runtime calls to a named set of conversion routines. By default, the conversions may produce unexpected results."), ::llvm::cl::init(std::string{})};
};

template <typename DerivedT>
class ExternalNameConversionBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExternalNameConversionBase;

  ExternalNameConversionBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExternalNameConversionBase(const ExternalNameConversionBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("external-name-interop");
  }
  ::llvm::StringRef getArgument() const override { return "external-name-interop"; }

  ::llvm::StringRef getDescription() const override { return "Convert name for external interoperability"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExternalNameConversion");
  }
  ::llvm::StringRef getName() const override { return "ExternalNameConversion"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExternalNameConversionBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemRefDataFlowOptBase : public ::mlir::OperationPass<::mlir::func::FuncOp> {
public:
  using Base = MemRefDataFlowOptBase;

  MemRefDataFlowOptBase() : ::mlir::OperationPass<::mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemRefDataFlowOptBase(const MemRefDataFlowOptBase &other) : ::mlir::OperationPass<::mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("fir-memref-dataflow-opt");
  }
  ::llvm::StringRef getArgument() const override { return "fir-memref-dataflow-opt"; }

  ::llvm::StringRef getDescription() const override { return "Perform store/load forwarding and potentially removing dead stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemRefDataFlowOpt");
  }
  ::llvm::StringRef getName() const override { return "MemRefDataFlowOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  registry.insert<mlir::func::FuncDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemRefDataFlowOptBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemoryAllocationOptBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = MemoryAllocationOptBase;

  MemoryAllocationOptBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemoryAllocationOptBase(const MemoryAllocationOptBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("memory-allocation-opt");
  }
  ::llvm::StringRef getArgument() const override { return "memory-allocation-opt"; }

  ::llvm::StringRef getDescription() const override { return "Convert stack to heap allocations and vice versa."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemoryAllocationOpt");
  }
  ::llvm::StringRef getName() const override { return "MemoryAllocationOpt"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<fir::FIROpsDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemoryAllocationOptBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> dynamicArrayOnHeap{*this, "dynamic-array-on-heap", ::llvm::cl::desc("Allocate all arrays with runtime determined size on heap."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::size_t> maxStackArraySize{*this, "maximum-array-alloc-size", ::llvm::cl::desc("Set maximum number of elements of an array allocated on the stack."), ::llvm::cl::init(~static_cast<std::size_t>(0))};
};

template <typename DerivedT>
class SimplifyIntrinsicsBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyIntrinsicsBase;

  SimplifyIntrinsicsBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyIntrinsicsBase(const SimplifyIntrinsicsBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-intrinsics");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-intrinsics"; }

  ::llvm::StringRef getDescription() const override { return "Intrinsics simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyIntrinsics");
  }
  ::llvm::StringRef getName() const override { return "SimplifyIntrinsics"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyIntrinsicsBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enableExperimental{*this, "enable-experimental", ::llvm::cl::desc("Enable experimental code that may not always work correctly"), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class SimplifyRegionLiteBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyRegionLiteBase;

  SimplifyRegionLiteBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyRegionLiteBase(const SimplifyRegionLiteBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-region-lite");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-region-lite"; }

  ::llvm::StringRef getDescription() const override { return "Region simplification"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyRegionLite");
  }
  ::llvm::StringRef getName() const override { return "SimplifyRegionLite"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyRegionLiteBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
